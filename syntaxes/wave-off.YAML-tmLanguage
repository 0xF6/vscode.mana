name: "Wave Language"
scopeName: source.wave
fileTypes:
    - wave
uuid: acd10959-e561-4695-9d2a-c6133f52a163
patterns:
    - include: "#preprocessor"
    - include: "#comment"
    - include: "#directives"
    - include: "#declarations"
    - include: "#script-top-level"
repository:
    directives:
        patterns:
            - include: "#extern-alias-directive"
            - include: "#using-directive"
            - include: "#attribute-section"
            - include: "#punctuation-semicolon"
    declarations:
        patterns:
            - include: "#namespace-declaration"
            - include: "#type-declarations"
            - include: "#punctuation-semicolon"
    script-top-level:
        patterns:
            - include: "#method-declaration"
            - include: "#statement"
            - include: "#punctuation-semicolon"
    type-declarations:
        patterns:
            - include: "#preprocessor"
            - include: "#comment"
            - include: "#storage-modifier"
            - include: "#class-declaration"
            - include: "#delegate-declaration"
            - include: "#enum-declaration"
            - include: "#interface-declaration"
            - include: "#struct-declaration"
            - include: "#attribute-section"
            - include: "#punctuation-semicolon"
    class-or-struct-members:
        patterns:
            - include: "#preprocessor"
            - include: "#comment"
            - include: "#storage-modifier"
            - include: "#type-declarations"
            - include: "#property-declaration"
            - include: "#field-declaration"
            - include: "#event-declaration"
            - include: "#indexer-declaration"
            - include: "#variable-initializer"
            - include: "#constructor-declaration"
            - include: "#destructor-declaration"
            - include: "#operator-declaration"
            - include: "#conversion-operator-declaration"
            - include: "#method-declaration"
            - include: "#attribute-section"
            - include: "#punctuation-semicolon"
    interface-members:
        patterns:
            - include: "#preprocessor"
            - include: "#comment"
            - include: "#property-declaration"
            - include: "#event-declaration"
            - include: "#indexer-declaration"
            - include: "#method-declaration"
            - include: "#attribute-section"
            - include: "#punctuation-semicolon"
    statement:
        patterns:
            - include: "#preprocessor"
            - include: "#comment"
            - include: "#while-statement"
            - include: "#do-statement"
            - include: "#for-statement"
            - include: "#foreach-statement"
            - include: "#if-statement"
            - include: "#else-part"
            - include: "#switch-statement"
            - include: "#goto-statement"
            - include: "#return-statement"
            - include: "#break-or-continue-statement"
            - include: "#throw-statement"
            - include: "#yield-statement"
            - include: "#await-statement"
            - include: "#try-statement"
            - include: "#checked-unchecked-statement"
            - include: "#lock-statement"
            - include: "#using-statement"
            - include: "#labeled-statement"
            - include: "#local-declaration"
            - include: "#block"
            - include: "#expression"
            - include: "#punctuation-semicolon"
    expression:
        patterns:
            - include: "#preprocessor"
            - include: "#comment"
            - include: "#checked-unchecked-expression"
            - include: "#typeof-or-default-expression"
            - include: "#nameof-expression"
            - include: "#throw-expression"
            - include: "#interpolated-string"
            - include: "#verbatim-interpolated-string"
            - include: "#this-or-base-expression"
            - include: "#conditional-operator"
            - include: "#expression-operators"
            - include: "#await-expression"
            - include: "#query-expression"
            - include: "#as-expression"
            - include: "#is-expression"
            - include: "#anonymous-method-expression"
            - include: "#object-creation-expression"
            - include: "#array-creation-expression"
            - include: "#anonymous-object-creation-expression"
            - include: "#invocation-expression"
            - include: "#member-access-expression"
            - include: "#element-access-expression"
            - include: "#cast-expression"
            - include: "#literal"
            - include: "#parenthesized-expression"
            - include: "#tuple-deconstruction-assignment"
            - include: "#initializer-expression"
            - include: "#identifier"
    extern-alias-directive:
        begin: '\s*(extern)\b\s*(alias)\b\s*(@?[_[:alpha:]][_[:alnum:]]*)'
        beginCaptures:
            "1":
                name: keyword.other.extern.wave
            "2":
                name: keyword.other.alias.wave
            "3":
                name: variable.other.alias.wave
        end: "(?=;)"
    using-directive:
        patterns:
            - begin: \b(using)\b\s+(static)\s+
              beginCaptures:
                  "1": { name: keyword.other.using.wave }
                  "2": { name: keyword.other.static.wave }
              end: "(?=;)"
              patterns:
                  - { include: "#type" }
            - begin: '\b(using)\s+(?=(@?[_[:alpha:]][_[:alnum:]]*)\s*=)'
              beginCaptures:
                  "1": { name: keyword.other.using.wave }
                  "2": { name: entity.name.type.alias.wave }
              end: "(?=;)"
              patterns:
                  - { include: "#comment" }
                  - { include: "#type" }
                  - { include: "#operator-assignment" }
            - begin: '\b(using)\s*'
              beginCaptures:
                  "1": { name: keyword.other.using.wave }
              end: "(?=;)"
              patterns:
                  - { include: "#comment" }
                  - {
                        name: entity.name.type.namespace.wave,
                        match: "@?[_[:alpha:]][_[:alnum:]]*",
                    }
                  - { include: "#operator-assignment" }
    attribute-section:
        begin: '(\[)(assembly|module|field|event|method|param|property|return|type)?(\:)?'
        beginCaptures:
            "1":
                name: punctuation.squarebracket.open.wave
            "2":
                name: keyword.other.attribute-specifier.wave
            "3":
                name: punctuation.separator.colon.wave
        end: '(\])'
        endCaptures:
            "1":
                name: punctuation.squarebracket.close.wave
        patterns:
            - include: "#comment"
            - include: "#attribute"
            - include: "#punctuation-comma"
    attribute:
        patterns:
            - include: "#type-name"
            - include: "#attribute-arguments"
    attribute-arguments:
        begin: (\()
        beginCaptures:
            "1":
                name: punctuation.parenthesis.open.wave
        end: (\))
        endCaptures:
            "1":
                name: punctuation.parenthesis.close.wave
        patterns:
            - include: "#attribute-named-argument"
            - include: "#expression"
            - include: "#punctuation-comma"
    attribute-named-argument:
        begin: '(@?[_[:alpha:]][_[:alnum:]]*)\s*(?==)'
        beginCaptures:
            "1":
                name: entity.name.variable.property.wave
        end: '(?=(,|\)))'
        patterns:
            - include: "#operator-assignment"
            - include: "#expression"
    namespace-declaration:
        begin: \b(namespace)\s+
        beginCaptures:
            "1":
                name: keyword.other.namespace.wave
        end: '(?<=\})'
        patterns:
            - include: "#comment"
            - name: entity.name.type.namespace.wave
              match: "@?[_[:alpha:]][_[:alnum:]]*"
            - include: "#punctuation-accessor"
            - begin: '\{'
              beginCaptures:
                  "0": { name: punctuation.curlybrace.open.wave }
              end: '\}'
              endCaptures:
                  "0": { name: punctuation.curlybrace.close.wave }
              patterns:
                  - { include: "#declarations" }
                  - { include: "#using-directive" }
                  - { include: "#punctuation-semicolon" }
    storage-modifier:
        name: storage.modifier.wave
        match: '(?<!\.)\b(new|public|protected|internal|private|abstract|virtual|override|sealed|static|partial|readonly|volatile|const|extern|async|unsafe|ref)\b'
    class-declaration:
        begin: '(?=\bclass\b)'
        end: '(?<=\})'
        patterns:
            - begin: "(?x)\\b(class)\\b\\s+(@?[_[:alpha:]][_[:alnum:]]*)\\s*"
              beginCaptures:
                  "1": { name: keyword.other.class.wave }
                  "2": { name: entity.name.type.class.wave }
              end: '(?=\{)'
              patterns:
                  - { include: "#comment" }
                  - { include: "#type-parameter-list" }
                  - { include: "#base-types" }
                  - { include: "#generic-constraints" }
            - begin: '\{'
              beginCaptures:
                  "0": { name: punctuation.curlybrace.open.wave }
              end: '\}'
              endCaptures:
                  "0": { name: punctuation.curlybrace.close.wave }
              patterns:
                  - { include: "#class-or-struct-members" }
            - include: "#preprocessor"
            - include: "#comment"
    delegate-declaration:
        begin: "(?x)(?:\\b(delegate)\\b)\\s+(?<type-name>  (?:    (?:ref\\s+(?:readonly\\s+)?)?   # ref return    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))\\s+(\\g<identifier>)\\s*(<([^<>]+)>)?\\s*(?=\\()"
        beginCaptures:
            "1":
                name: keyword.other.delegate.wave
            "2":
                patterns:
                    - { include: "#type" }
            "7":
                name: entity.name.type.delegate.wave
            "8":
                patterns:
                    - { include: "#type-parameter-list" }
        end: "(?=;)"
        patterns:
            - include: "#comment"
            - include: "#parenthesized-parameter-list"
            - include: "#generic-constraints"
    enum-declaration:
        begin: '(?=\benum\b)'
        end: '(?<=\})'
        patterns:
            - begin: "(?=enum)"
              end: '(?=\{)'
              patterns:
                  - { include: "#comment" }
                  - {
                        match: '(enum)\s+(@?[_[:alpha:]][_[:alnum:]]*)',
                        captures:
                            {
                                "1": { name: keyword.other.enum.wave },
                                "2": { name: entity.name.type.enum.wave },
                            },
                    }
                  - {
                        begin: ":",
                        beginCaptures:
                            { "0": { name: punctuation.separator.colon.wave } },
                        end: '(?=\{)',
                        patterns: [{ include: "#type" }],
                    }
            - begin: '\{'
              beginCaptures:
                  "0": { name: punctuation.curlybrace.open.wave }
              end: '\}'
              endCaptures:
                  "0": { name: punctuation.curlybrace.close.wave }
              patterns:
                  - { include: "#preprocessor" }
                  - { include: "#comment" }
                  - { include: "#attribute-section" }
                  - { include: "#punctuation-comma" }
                  - {
                        begin: "@?[_[:alpha:]][_[:alnum:]]*",
                        beginCaptures:
                            {
                                "0":
                                    {
                                        name: entity.name.variable.enum-member.wave,
                                    },
                            },
                        end: '(?=(,|\}))',
                        patterns:
                            [
                                { include: "#comment" },
                                { include: "#variable-initializer" },
                            ],
                    }
            - include: "#preprocessor"
            - include: "#comment"
    interface-declaration:
        begin: '(?=\binterface\b)'
        end: '(?<=\})'
        patterns:
            - begin: "(?x)(interface)\\b\\s+(@?[_[:alpha:]][_[:alnum:]]*)"
              beginCaptures:
                  "1": { name: keyword.other.interface.wave }
                  "2": { name: entity.name.type.interface.wave }
              end: '(?=\{)'
              patterns:
                  - { include: "#comment" }
                  - { include: "#type-parameter-list" }
                  - { include: "#base-types" }
                  - { include: "#generic-constraints" }
            - begin: '\{'
              beginCaptures:
                  "0": { name: punctuation.curlybrace.open.wave }
              end: '\}'
              endCaptures:
                  "0": { name: punctuation.curlybrace.close.wave }
              patterns:
                  - { include: "#interface-members" }
            - include: "#preprocessor"
            - include: "#comment"
    struct-declaration:
        begin: '(?=\bstruct\b)'
        end: '(?<=\})'
        patterns:
            - begin: "(?x)(struct)\\b\\s+(@?[_[:alpha:]][_[:alnum:]]*)"
              beginCaptures:
                  "1": { name: keyword.other.struct.wave }
                  "2": { name: entity.name.type.struct.wave }
              end: '(?=\{)'
              patterns:
                  - { include: "#comment" }
                  - { include: "#type-parameter-list" }
                  - { include: "#base-types" }
                  - { include: "#generic-constraints" }
            - begin: '\{'
              beginCaptures:
                  "0": { name: punctuation.curlybrace.open.wave }
              end: '\}'
              endCaptures:
                  "0": { name: punctuation.curlybrace.close.wave }
              patterns:
                  - { include: "#class-or-struct-members" }
            - include: "#preprocessor"
            - include: "#comment"
    type-parameter-list:
        begin: \<
        beginCaptures:
            "0":
                name: punctuation.definition.typeparameters.begin.wave
        end: \>
        endCaptures:
            "0":
                name: punctuation.definition.typeparameters.end.wave
        patterns:
            - match: \b(in|out)\b
              captures:
                  "1": { name: storage.modifier.wave }
            - match: '(@?[_[:alpha:]][_[:alnum:]]*)\b'
              captures:
                  "1": { name: entity.name.type.type-parameter.wave }
            - include: "#comment"
            - include: "#punctuation-comma"
            - include: "#attribute-section"
    base-types:
        begin: ":"
        beginCaptures:
            "0":
                name: punctuation.separator.colon.wave
        end: '(?=\{|where)'
        patterns:
            - include: "#type"
            - include: "#punctuation-comma"
            - include: "#preprocessor"
    generic-constraints:
        begin: '(where)\s+(@?[_[:alpha:]][_[:alnum:]]*)\s*(:)'
        beginCaptures:
            "1":
                name: keyword.other.where.wave
            "2":
                name: storage.type.wave
            "3":
                name: punctuation.separator.colon.wave
        end: '(?=\{|where|;|=>)'
        patterns:
            - name: keyword.other.class.wave
              match: \bclass\b
            - name: keyword.other.struct.wave
              match: \bstruct\b
            - match: '(new)\s*(\()\s*(\))'
              captures:
                  "1": { name: keyword.other.new.wave }
                  "2": { name: punctuation.parenthesis.open.wave }
                  "3": { name: punctuation.parenthesis.close.wave }
            - include: "#type"
            - include: "#punctuation-comma"
            - include: "#generic-constraints"
    field-declaration:
        begin: "(?x)(?<type-name>  (?:    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))\\s+(\\g<identifier>)\\s* # first field name(?!=>|==)(?=,|;|=|$)"
        beginCaptures:
            "1":
                patterns:
                    - { include: "#type" }
            "6":
                name: entity.name.variable.field.wave
        end: "(?=;)"
        patterns:
            - name: entity.name.variable.field.wave
              match: "@?[_[:alpha:]][_[:alnum:]]*"
            - include: "#punctuation-comma"
            - include: "#comment"
            - include: "#variable-initializer"
            - include: "#class-or-struct-members"
    property-declaration:
        begin: "(?x)# The negative lookahead below ensures that we don't match nested types# or other declarations as properties.(?![[:word:][:space:]]*\\b(?:class|interface|struct|enum|event)\\b)(?<return-type>  (?<type-name>    (?:      (?:ref\\s+(?:readonly\\s+)?)?   # ref return      (?:        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification        (?<name-and-type-args> # identifier + type arguments (if any)          \\g<identifier>\\s*          (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?        )        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))      )      (?:\\s*\\?\\s*)? # nullable suffix?      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?    )  )\\s+)(?<interface-name>\\g<type-name>\\s*\\.\\s*)?(?<property-name>\\g<identifier>)\\s*(?=\\{|=>|$)"
        beginCaptures:
            "1":
                patterns:
                    - { include: "#type" }
            "7":
                patterns:
                    - { include: "#type" }
                    - { include: "#punctuation-accessor" }
            "8":
                name: entity.name.variable.property.wave
        end: '(?<=\})|(?=;)'
        patterns:
            - include: "#comment"
            - include: "#property-accessors"
            - include: "#expression-body"
            - include: "#variable-initializer"
            - include: "#class-or-struct-members"
    indexer-declaration:
        begin: "(?x)(?<return-type>  (?<type-name>    (?:      (?:ref\\s+(?:readonly\\s+)?)?   # ref return      (?:        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification        (?<name-and-type-args> # identifier + type arguments (if any)          \\g<identifier>\\s*          (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?        )        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))      )      (?:\\s*\\?\\s*)? # nullable suffix?      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?    )  )\\s+)(?<interface-name>\\g<type-name>\\s*\\.\\s*)?(?<indexer-name>this)\\s*(?=\\[)"
        beginCaptures:
            "1":
                patterns:
                    - { include: "#type" }
            "7":
                patterns:
                    - { include: "#type" }
                    - { include: "#punctuation-accessor" }
            "8":
                name: keyword.other.this.wave
        end: '(?<=\})|(?=;)'
        patterns:
            - include: "#comment"
            - include: "#bracketed-parameter-list"
            - include: "#property-accessors"
            - include: "#expression-body"
            - include: "#variable-initializer"
    event-declaration:
        begin: "(?x)\\b(event)\\b\\s*(?<return-type>  (?<type-name>    (?:      (?:        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification        (?<name-and-type-args> # identifier + type arguments (if any)          \\g<identifier>\\s*          (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?        )        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))      )      (?:\\s*\\?\\s*)? # nullable suffix?      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?    )  )\\s+)(?<interface-name>\\g<type-name>\\s*\\.\\s*)?(?<event-names>\\g<identifier>(?:\\s*,\\s*\\g<identifier>)*)\\s*(?=\\{|;|$)"
        beginCaptures:
            "1":
                name: keyword.other.event.wave
            "2":
                patterns:
                    - { include: "#type" }
            "8":
                patterns:
                    - { include: "#type" }
                    - { include: "#punctuation-accessor" }
            "9":
                patterns:
                    - {
                          name: entity.name.variable.event.wave,
                          match: "@?[_[:alpha:]][_[:alnum:]]*",
                      }
                    - { include: "#punctuation-comma" }
        end: '(?<=\})|(?=;)'
        patterns:
            - include: "#comment"
            - include: "#event-accessors"
            - include: "#punctuation-comma"
    property-accessors:
        begin: '\{'
        beginCaptures:
            "0":
                name: punctuation.curlybrace.open.wave
        end: '\}'
        endCaptures:
            "0":
                name: punctuation.curlybrace.close.wave
        patterns:
            - name: storage.modifier.wave
              match: \b(private|protected|internal)\b
            - name: keyword.other.get.wave
              match: \b(get)\b
            - name: keyword.other.set.wave
              match: \b(set)\b
            - include: "#comment"
            - include: "#attribute-section"
            - include: "#expression-body"
            - include: "#block"
            - include: "#punctuation-semicolon"
    event-accessors:
        begin: '\{'
        beginCaptures:
            "0":
                name: punctuation.curlybrace.open.wave
        end: '\}'
        endCaptures:
            "0":
                name: punctuation.curlybrace.close.wave
        patterns:
            - name: keyword.other.add.wave
              match: \b(add)\b
            - name: keyword.other.remove.wave
              match: \b(remove)\b
            - include: "#comment"
            - include: "#attribute-section"
            - include: "#expression-body"
            - include: "#block"
            - include: "#punctuation-semicolon"
    method-declaration:
        begin: "(?x)(?<return-type>  (?<type-name>    (?:      (?:ref\\s+(?:readonly\\s+)?)?   # ref return      (?:        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification        (?<name-and-type-args> # identifier + type arguments (if any)          \\g<identifier>\\s*          (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?        )        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))      )      (?:\\s*\\?\\s*)? # nullable suffix?      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?    )  )\\s+)(?<interface-name>\\g<type-name>\\s*\\.\\s*)?(\\g<identifier>)\\s*(<([^<>]+)>)?\\s*(?=\\()"
        beginCaptures:
            "1":
                patterns:
                    - { include: "#type" }
            "7":
                patterns:
                    - { include: "#type" }
                    - { include: "#punctuation-accessor" }
            "8":
                name: entity.name.function.wave
            "9":
                patterns:
                    - { include: "#type-parameter-list" }
        end: '(?<=\})|(?=;)'
        patterns:
            - include: "#comment"
            - include: "#parenthesized-parameter-list"
            - include: "#generic-constraints"
            - include: "#expression-body"
            - include: "#block"
    constructor-declaration:
        begin: '(?=@?[_[:alpha:]][_[:alnum:]]*\s*\()'
        end: '(?<=\})|(?=;)'
        patterns:
            - match: '(@?[_[:alpha:]][_[:alnum:]]*)\b'
              captures:
                  "1": { name: entity.name.function.wave }
            - begin: "(:)"
              beginCaptures:
                  "1": { name: punctuation.separator.colon.wave }
              end: '(?=\{|=>)'
              patterns:
                  - { include: "#constructor-initializer" }
            - include: "#parenthesized-parameter-list"
            - include: "#preprocessor"
            - include: "#comment"
            - include: "#expression-body"
            - include: "#block"
    constructor-initializer:
        begin: '\b(?:(base)|(this))\b\s*(?=\()'
        beginCaptures:
            "1":
                name: keyword.other.base.wave
            "2":
                name: keyword.other.this.wave
        end: '(?<=\))'
        patterns:
            - include: "#argument-list"
    destructor-declaration:
        begin: '(~)(@?[_[:alpha:]][_[:alnum:]]*)\s*(?=\()'
        beginCaptures:
            "1":
                name: punctuation.tilde.wave
            "2":
                name: entity.name.function.wave
        end: '(?<=\})|(?=;)'
        patterns:
            - include: "#comment"
            - include: "#parenthesized-parameter-list"
            - include: "#expression-body"
            - include: "#block"
    operator-declaration:
        begin: "(?x)(?<type-name>  (?:    (?:ref\\s+(?:readonly\\s+)?)?   # ref return    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))\\s*(?<operator-keyword>(?:\\b(?:operator)))\\s*(?<operator>(?:\\+|-|\\*|/|%|&|\\||\\^|\\<\\<|\\>\\>|==|!=|\\>|\\<|\\>=|\\<=|!|~|\\+\\+|--|true|false))\\s*(?=\\()"
        beginCaptures:
            "1":
                patterns:
                    - { include: "#type" }
            "6":
                name: keyword.other.operator-decl.wave
            "7":
                name: entity.name.function.wave
        end: '(?<=\})|(?=;)'
        patterns:
            - include: "#comment"
            - include: "#parenthesized-parameter-list"
            - include: "#expression-body"
            - include: "#block"
    conversion-operator-declaration:
        begin: "(?x)(?<explicit-or-implicit-keyword>(?:\\b(?:explicit|implicit)))\\s*(?<operator-keyword>(?:\\b(?:operator)))\\s*(?<type-name>  (?:    (?:ref\\s+(?:readonly\\s+)?)?   # ref return    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))\\s*(?=\\()"
        beginCaptures:
            "1":
                patterns:
                    - {
                          match: \b(explicit)\b,
                          captures:
                              { "1": { name: keyword.other.explicit.wave } },
                      }
                    - {
                          match: \b(implicit)\b,
                          captures:
                              { "1": { name: keyword.other.implicit.wave } },
                      }
            "2":
                name: keyword.other.operator-decl.wave
            "3":
                patterns:
                    - { include: "#type" }
        end: '(?<=\})|(?=;)'
        patterns:
            - include: "#comment"
            - include: "#parenthesized-parameter-list"
            - include: "#expression-body"
            - include: "#block"
    block:
        begin: '\{'
        beginCaptures:
            "0":
                name: punctuation.curlybrace.open.wave
        end: '\}'
        endCaptures:
            "0":
                name: punctuation.curlybrace.close.wave
        patterns:
            - include: "#statement"
    variable-initializer:
        begin: "(?<!=|!)(=)(?!=|>)"
        beginCaptures:
            "1":
                name: keyword.operator.assignment.wave
        end: '(?=[,\)\];}])'
        patterns:
            - include: "#ref-modifier"
            - include: "#expression"
    expression-body:
        begin: "=>"
        beginCaptures:
            "0":
                name: keyword.operator.arrow.wave
        end: '(?=[,\);}])'
        patterns:
            - include: "#ref-modifier"
            - include: "#expression"
    goto-statement:
        begin: '(?<!\.)\b(goto)\b'
        beginCaptures:
            "1":
                name: keyword.control.goto.wave
        end: "(?=;)"
        patterns:
            - begin: \b(case)\b
              beginCaptures:
                  "1": { name: keyword.control.case.wave }
              end: "(?=;)"
              patterns:
                  - { include: "#expression" }
            - match: \b(default)\b
              captures:
                  "1": { name: keyword.control.default.wave }
            - name: entity.name.label.wave
              match: "@?[_[:alpha:]][_[:alnum:]]*"
    return-statement:
        begin: '(?<!\.)\b(return)\b'
        beginCaptures:
            "1":
                name: keyword.control.flow.return.wave
        end: "(?=;)"
        patterns:
            - include: "#ref-modifier"
            - include: "#expression"
    break-or-continue-statement:
        match: '(?<!\.)\b(?:(break)|(continue))\b'
        captures:
            "1":
                name: keyword.control.flow.break.wave
            "2":
                name: keyword.control.flow.continue.wave
    throw-statement:
        begin: '(?<!\.)\b(throw)\b'
        beginCaptures:
            "1":
                name: keyword.control.flow.throw.wave
        end: "(?=;)"
        patterns:
            - include: "#expression"
    yield-statement:
        patterns:
            - include: "#yield-return-statement"
            - include: "#yield-break-statement"
    yield-return-statement:
        begin: '(?<!\.)\b(yield)\b\s*\b(return)\b'
        beginCaptures:
            "1":
                name: keyword.control.flow.yield.wave
            "2":
                name: keyword.control.flow.return.wave
        end: "(?=;)"
        patterns:
            - include: "#expression"
    yield-break-statement:
        match: '(?<!\.)\b(yield)\b\s*\b(break)\b'
        captures:
            "1":
                name: keyword.control.flow.yield.wave
            "2":
                name: keyword.control.flow.break.wave
    await-statement:
        begin: '(?<!\.)\b(await)\b'
        beginCaptures:
            "1":
                name: keyword.other.await.wave
        end: "(?=;)"
        patterns:
            - include: "#expression"
    if-statement:
        begin: '(?<!\.)\b(if)\b\s*(?=\()'
        beginCaptures:
            "1":
                name: keyword.control.conditional.if.wave
        end: '(?<=\})|(?=;)'
        patterns:
            - begin: \(
              beginCaptures:
                  "0": { name: punctuation.parenthesis.open.wave }
              end: \)
              endCaptures:
                  "0": { name: punctuation.parenthesis.close.wave }
              patterns:
                  - { include: "#expression" }
            - include: "#statement"
    else-part:
        begin: '(?<!\.)\b(else)\b'
        beginCaptures:
            "1":
                name: keyword.control.conditional.else.wave
        end: '(?<=\})|(?=;)'
        patterns:
            - include: "#statement"
    switch-statement:
        begin: '(?<!\.)\b(switch)\b\s*(?=\()'
        beginCaptures:
            "1":
                name: keyword.control.switch.wave
        end: '(?<=\})'
        patterns:
            - begin: \(
              beginCaptures:
                  "0": { name: punctuation.parenthesis.open.wave }
              end: \)
              endCaptures:
                  "0": { name: punctuation.parenthesis.close.wave }
              patterns:
                  - { include: "#expression" }
            - begin: '\{'
              beginCaptures:
                  "0": { name: punctuation.curlybrace.open.wave }
              end: '\}'
              endCaptures:
                  "0": { name: punctuation.curlybrace.close.wave }
              patterns:
                  - { include: "#switch-label" }
                  - { include: "#statement" }
    switch-label:
        patterns:
            - begin: '(?<!\.)\b(case)\b\s+'
              beginCaptures:
                  "1": { name: keyword.control.case.wave }
              end: ":"
              endCaptures:
                  "0": { name: punctuation.separator.colon.wave }
              patterns:
                  - { include: "#expression" }
            - match: '(?<!\.)\b(default)\b\s*(:)'
              captures:
                  "1": { name: keyword.control.default.wave }
                  "2": { name: punctuation.separator.colon.wave }
    do-statement:
        begin: '(?<!\.)\b(do)\b'
        beginCaptures:
            "1":
                name: keyword.control.loop.do.wave
        end: "(?=;|})"
        patterns:
            - include: "#statement"
    while-statement:
        begin: '(?<!\.)\b(while)\b\s*(?=\()'
        beginCaptures:
            "1":
                name: keyword.control.loop.while.wave
        end: '(?<=\})|(?=;)'
        patterns:
            - begin: \(
              beginCaptures:
                  "0": { name: punctuation.parenthesis.open.wave }
              end: \)
              endCaptures:
                  "0": { name: punctuation.parenthesis.close.wave }
              patterns:
                  - { include: "#expression" }
            - include: "#statement"
    for-statement:
        begin: '(?<!\.)\b(for)\b\s*(?=\()'
        beginCaptures:
            "1":
                name: keyword.control.loop.for.wave
        end: '(?<=\})|(?=;)'
        patterns:
            - begin: \(
              beginCaptures:
                  "0": { name: punctuation.parenthesis.open.wave }
              end: \)
              endCaptures:
                  "0": { name: punctuation.parenthesis.close.wave }
              patterns:
                  - { include: "#local-variable-declaration" }
                  - { include: "#expression" }
                  - { include: "#punctuation-comma" }
                  - { include: "#punctuation-semicolon" }
            - include: "#statement"
    foreach-statement:
        begin: '(?<!\.)\b(foreach)\b\s*(?=\()'
        beginCaptures:
            "1":
                name: keyword.control.loop.foreach.wave
        end: '(?<=\})|(?=;)'
        patterns:
            - begin: \(
              beginCaptures:
                  "0": { name: punctuation.parenthesis.open.wave }
              end: \)
              endCaptures:
                  "0": { name: punctuation.parenthesis.close.wave }
              patterns:
                  - {
                        match: "(?x)(?:  (\\bvar\\b)|  (?<type-name>    (?:      (?:        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification        (?<name-and-type-args> # identifier + type arguments (if any)          \\g<identifier>\\s*          (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?        )        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))      )      (?:\\s*\\?\\s*)? # nullable suffix?      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?    )  ))\\s+(\\g<identifier>)\\s+\\b(in)\\b",
                        captures:
                            {
                                "1": { name: keyword.other.var.wave },
                                "2": { patterns: [{ include: "#type" }] },
                                "7": { name: entity.name.variable.local.wave },
                                "8": { name: keyword.control.loop.in.wave },
                            },
                    }
                  - {
                        match: "(?x) # match foreach (var (x, y) in ...)(?:\\b(var)\\b\\s*)?(?<tuple>\\((?:[^\\(\\)]|\\g<tuple>)+\\))\\s+\\b(in)\\b",
                        captures:
                            {
                                "1": { name: keyword.other.var.wave },
                                "2":
                                    {
                                        patterns:
                                            [
                                                {
                                                    include: "#tuple-declaration-deconstruction-element-list",
                                                },
                                            ],
                                    },
                                "3": { name: keyword.control.loop.in.wave },
                            },
                    }
                  - { include: "#expression" }
            - include: "#statement"
    try-statement:
        patterns:
            - include: "#try-block"
            - include: "#catch-clause"
            - include: "#finally-clause"
    try-block:
        begin: '(?<!\.)\b(try)\b'
        beginCaptures:
            "1":
                name: keyword.control.try.wave
        end: '(?<=\})'
        patterns:
            - include: "#comment"
            - include: "#block"
    finally-clause:
        begin: '(?<!\.)\b(finally)\b'
        beginCaptures:
            "1":
                name: keyword.control.try.finally.wave
        end: '(?<=\})'
        patterns:
            - include: "#comment"
            - include: "#block"
    catch-clause:
        begin: '(?<!\.)\b(catch)\b'
        beginCaptures:
            "1":
                name: keyword.control.try.catch.wave
        end: '(?<=\})'
        patterns:
            - begin: \(
              beginCaptures:
                  "0": { name: punctuation.parenthesis.open.wave }
              end: \)
              endCaptures:
                  "0": { name: punctuation.parenthesis.close.wave }
              patterns:
                  - {
                        match: "(?x)(?<type-name>  (?:    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))\\s*(?:(\\g<identifier>)\\b)?",
                        captures:
                            {
                                "1": { patterns: [{ include: "#type" }] },
                                "6": { name: entity.name.variable.local.wave },
                            },
                    }
            - include: "#when-clause"
            - include: "#comment"
            - include: "#block"
    when-clause:
        begin: '(?<!\.)\b(when)\b\s*(\()'
        beginCaptures:
            "1":
                name: keyword.control.try.when.wave
            "2":
                name: punctuation.parenthesis.open.wave
        end: \)
        endCaptures:
            "0":
                name: punctuation.parenthesis.close.wave
        patterns:
            - include: "#expression"
            - include: "#comment"
    checked-unchecked-statement:
        begin: '(?<!\.)\b(?:(checked)|(unchecked))\b\s*(?!\()'
        beginCaptures:
            "1":
                name: keyword.other.checked.wave
            "2":
                name: keyword.other.unchecked.wave
        end: '(?<=\})'
        patterns:
            - include: "#block"
            - include: "#comment"
    lock-statement:
        begin: '(?<!\.)\b(lock)\b\s*(?=\()'
        beginCaptures:
            "1":
                name: keyword.other.lock.wave
        end: '(?<=\})|(?=;)'
        patterns:
            - begin: \(
              beginCaptures:
                  "0": { name: punctuation.parenthesis.open.wave }
              end: \)
              endCaptures:
                  "0": { name: punctuation.parenthesis.close.wave }
              patterns:
                  - { include: "#expression" }
            - include: "#statement"
    using-statement:
        begin: '(?<!\.)\b(using)\b\s*(?=\()'
        beginCaptures:
            "1":
                name: keyword.other.using.wave
        end: '(?=\;|})'
        patterns:
            - begin: \(
              beginCaptures:
                  "0": { name: punctuation.parenthesis.open.wave }
              end: \)
              endCaptures:
                  "0": { name: punctuation.parenthesis.close.wave }
              patterns:
                  - { include: "#local-variable-declaration" }
                  - { include: "#expression" }
            - include: "#statement"
    labeled-statement:
        match: '(@?[_[:alpha:]][_[:alnum:]]*)\s*(:)'
        captures:
            "1":
                name: entity.name.label.wave
            "2":
                name: punctuation.separator.colon.wave
    local-declaration:
        patterns:
            - include: "#local-constant-declaration"
            - include: "#local-variable-declaration"
            - include: "#local-tuple-var-deconstruction"
    local-variable-declaration:
        begin: "(?x)(?:  (?:(\\bref)\\s+(?:(\\breadonly)\\s+)?)?(\\bvar\\b)| # ref local  (?<type-name>    (?:      (?:ref\\s+(?:readonly\\s+)?)?   # ref local      (?:        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification        (?<name-and-type-args> # identifier + type arguments (if any)          \\g<identifier>\\s*          (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?        )        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))      )      (?:\\s*\\?\\s*)? # nullable suffix?      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?    )  ))\\s+(\\g<identifier>)\\s*(?!=>)(?=,|;|=|\\))"
        beginCaptures:
            "1":
                name: storage.modifier.wave
            "2":
                name: storage.modifier.wave
            "3":
                name: keyword.other.var.wave
            "4":
                patterns:
                    - { include: "#type" }
            "9":
                name: entity.name.variable.local.wave
        end: '(?=;|\))'
        patterns:
            - name: entity.name.variable.local.wave
              match: "@?[_[:alpha:]][_[:alnum:]]*"
            - include: "#punctuation-comma"
            - include: "#comment"
            - include: "#variable-initializer"
    local-constant-declaration:
        begin: "(?x)(?<const-keyword>\\b(?:const)\\b)\\s*(?<type-name>  (?:    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))\\s+(\\g<identifier>)\\s*(?=,|;|=)"
        beginCaptures:
            "1":
                name: storage.modifier.wave
            "2":
                patterns:
                    - { include: "#type" }
            "7":
                name: entity.name.variable.local.wave
        end: "(?=;)"
        patterns:
            - name: entity.name.variable.local.wave
              match: "@?[_[:alpha:]][_[:alnum:]]*"
            - include: "#punctuation-comma"
            - include: "#comment"
            - include: "#variable-initializer"
    local-tuple-var-deconstruction:
        begin: "(?x) # e.g. var (x, y) = GetPoint();(?:\\b(var)\\b\\s*)(?<tuple>\\((?:[^\\(\\)]|\\g<tuple>)+\\))\\s*(?=;|=|\\))"
        beginCaptures:
            "1":
                name: keyword.other.var.wave
            "2":
                patterns:
                    - {
                          include: "#tuple-declaration-deconstruction-element-list",
                      }
        end: '(?=;|\))'
        patterns:
            - include: "#comment"
            - include: "#variable-initializer"
    tuple-deconstruction-assignment:
        match: "(?x)(?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\\s*(?!=>|==)(?==)"
        captures:
            "1":
                patterns:
                    - { include: "#tuple-deconstruction-element-list" }
    tuple-declaration-deconstruction-element-list:
        begin: \(
        beginCaptures:
            "0":
                name: punctuation.parenthesis.open.wave
        end: \)
        endCaptures:
            "0":
                name: punctuation.parenthesis.close.wave
        patterns:
            - include: "#comment"
            - include: "#tuple-declaration-deconstruction-element-list"
            - include: "#declaration-expression-tuple"
            - include: "#punctuation-comma"
            - match: "(?x) # e.g. x(@?[_[:alpha:]][_[:alnum:]]*)\\b\\s*(?=[,)])"
              captures:
                  "1": { name: entity.name.variable.tuple-element.wave }
    tuple-deconstruction-element-list:
        begin: \(
        beginCaptures:
            "0":
                name: punctuation.parenthesis.open.wave
        end: \)
        endCaptures:
            "0":
                name: punctuation.parenthesis.close.wave
        patterns:
            - include: "#comment"
            - include: "#tuple-deconstruction-element-list"
            - include: "#declaration-expression-tuple"
            - include: "#punctuation-comma"
            - match: "(?x) # e.g. x(@?[_[:alpha:]][_[:alnum:]]*)\\b\\s*(?=[,)])"
              captures:
                  "1": { name: variable.other.readwrite.wave }
    declaration-expression-local:
        match: "(?x) # e.g. int x OR var x(?:  \\b(var)\\b|  (?<type-name>    (?:      (?:        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification        (?<name-and-type-args> # identifier + type arguments (if any)          \\g<identifier>\\s*          (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?        )        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))      )      (?:\\s*\\?\\s*)? # nullable suffix?      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?    )  ))\\s+(\\g<identifier>)\\b\\s*(?=[,)\\]])"
        captures:
            "1":
                name: keyword.other.var.wave
            "2":
                patterns:
                    - { include: "#type" }
            "7":
                name: entity.name.variable.local.wave
    declaration-expression-tuple:
        match: "(?x) # e.g. int x OR var x(?:  \\b(var)\\b|  (?<type-name>    (?:      (?:        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification        (?<name-and-type-args> # identifier + type arguments (if any)          \\g<identifier>\\s*          (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?        )        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))      )      (?:\\s*\\?\\s*)? # nullable suffix?      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?    )  ))\\s+(\\g<identifier>)\\b\\s*(?=[,)])"
        captures:
            "1":
                name: keyword.other.var.wave
            "2":
                patterns:
                    - { include: "#type" }
            "7":
                name: entity.name.variable.tuple-element.wave
    checked-unchecked-expression:
        begin: '(?<!\.)\b(?:(checked)|(unchecked))\b\s*(\()'
        beginCaptures:
            "1":
                name: keyword.other.checked.wave
            "2":
                name: keyword.other.unchecked.wave
            "3":
                name: punctuation.parenthesis.open.wave
        end: \)
        endCaptures:
            "0":
                name: punctuation.parenthesis.close.wave
        patterns:
            - include: "#expression"
    typeof-or-default-expression:
        begin: '(?<!\.)\b(?:(typeof)|(default))\b\s*(\()'
        beginCaptures:
            "1":
                name: keyword.other.typeof.wave
            "2":
                name: keyword.other.default.wave
            "3":
                name: punctuation.parenthesis.open.wave
        end: \)
        endCaptures:
            "0":
                name: punctuation.parenthesis.close.wave
        patterns:
            - include: "#type"
    nameof-expression:
        begin: '(?<!\.)\b(nameof)\b\s*(\()'
        beginCaptures:
            "1":
                name: keyword.other.nameof.wave
            "2":
                name: punctuation.parenthesis.open.wave
        end: \)
        endCaptures:
            "0":
                name: punctuation.parenthesis.close.wave
        patterns:
            - include: "#expression"
    throw-expression:
        match: '(?<!\.)\b(throw)\b'
        captures:
            "1":
                name: keyword.control.flow.throw.wave
    interpolated-string:
        name: string.quoted.double.wave
        begin: '\$"'
        beginCaptures:
            "0":
                name: punctuation.definition.string.begin.wave
        end: '(")|((?:[^\\\n])$)'
        endCaptures:
            "1":
                name: punctuation.definition.string.end.wave
            "2":
                name: invalid.illegal.newline.wave
        patterns:
            - include: "#string-character-escape"
            - include: "#interpolation"
    verbatim-interpolated-string:
        name: string.quoted.double.wave
        begin: '\$@"'
        beginCaptures:
            "0":
                name: punctuation.definition.string.begin.wave
        end: '"(?=[^"])'
        endCaptures:
            "0":
                name: punctuation.definition.string.end.wave
        patterns:
            - include: "#verbatim-string-character-escape"
            - include: "#interpolation"
    interpolation:
        name: meta.interpolation.wave
        begin: '(?<=[^\{]|^)((?:\{\{)*)(\{)(?=[^\{])'
        beginCaptures:
            "1":
                name: string.quoted.double.wave
            "2":
                name: punctuation.definition.interpolation.begin.wave
        end: '\}'
        endCaptures:
            "0":
                name: punctuation.definition.interpolation.end.wave
        patterns:
            - include: "#expression"
    literal:
        patterns:
            - include: "#boolean-literal"
            - include: "#null-literal"
            - include: "#numeric-literal"
            - include: "#char-literal"
            - include: "#string-literal"
            - include: "#verbatim-string-literal"
            - include: "#tuple-literal"
    boolean-literal:
        patterns:
            - name: constant.language.boolean.true.wave
              match: '(?<!\.)\btrue\b'
            - name: constant.language.boolean.false.wave
              match: '(?<!\.)\bfalse\b'
    null-literal:
        name: constant.language.null.wave
        match: '(?<!\.)\bnull\b'
    numeric-literal:
        patterns:
            - name: constant.numeric.hex.wave
              match: '\b0(x|X)[0-9a-fA-F_]+(U|u|L|l|UL|Ul|uL|ul|LU|Lu|lU|lu)?\b'
            - name: constant.numeric.binary.wave
              match: '\b0(b|B)[01_]+(U|u|L|l|UL|Ul|uL|ul|LU|Lu|lU|lu)?\b'
            - name: constant.numeric.decimal.wave
              match: '\b([0-9_]+)?\.[0-9_]+((e|E)[0-9]+)?(F|f|D|d|M|m)?\b'
            - name: constant.numeric.decimal.wave
              match: '\b[0-9_]+(e|E)[0-9_]+(F|f|D|d|M|m)?\b'
            - name: constant.numeric.decimal.wave
              match: '\b[0-9_]+(F|f|D|d|M|m)\b'
            - name: constant.numeric.decimal.wave
              match: '\b[0-9_]+(U|u|L|l|UL|Ul|uL|ul|LU|Lu|lU|lu)?\b'
    char-literal:
        name: string.quoted.single.wave
        begin: "'"
        beginCaptures:
            "0":
                name: punctuation.definition.char.begin.wave
        end: '(\'')|((?:[^\\\n])$)'
        endCaptures:
            "1":
                name: punctuation.definition.char.end.wave
            "2":
                name: invalid.illegal.newline.wave
        patterns:
            - include: "#char-character-escape"
    char-character-escape:
        name: constant.character.escape.wave
        match: '\\([''"\\0abfnrtv]|x[0-9a-fA-F]{1,4}|u[0-9a-fA-F]{4})'
    string-literal:
        name: string.quoted.double.wave
        begin: '(?<!@)"'
        beginCaptures:
            "0":
                name: punctuation.definition.string.begin.wave
        end: '(")|((?:[^\\\n])$)'
        endCaptures:
            "1":
                name: punctuation.definition.string.end.wave
            "2":
                name: invalid.illegal.newline.wave
        patterns:
            - include: "#string-character-escape"
    string-character-escape:
        name: constant.character.escape.wave
        match: '\\([''"\\0abfnrtv]|x[0-9a-fA-F]{1,4}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4})'
    verbatim-string-literal:
        name: string.quoted.double.wave
        begin: '@"'
        beginCaptures:
            "0":
                name: punctuation.definition.string.begin.wave
        end: '"(?=[^"])'
        endCaptures:
            "0":
                name: punctuation.definition.string.end.wave
        patterns:
            - include: "#verbatim-string-character-escape"
    verbatim-string-character-escape:
        name: constant.character.escape.wave
        match: '""'
    tuple-literal:
        begin: '(\()(?=.*[:,])'
        beginCaptures:
            "1":
                name: punctuation.parenthesis.open.wave
        end: \)
        endCaptures:
            "0":
                name: punctuation.parenthesis.close.wave
        patterns:
            - include: "#comment"
            - include: "#tuple-literal-element"
            - include: "#punctuation-comma"
    tuple-literal-element:
        begin: "(?x)(?:(@?[_[:alpha:]][_[:alnum:]]*)\\s*(:)\\s*)?(?![,)])"
        beginCaptures:
            "0":
                name: entity.name.variable.tuple-element.wave
            "1":
                name: punctuation.separator.colon.wave
        end: "(?=[,)])"
        patterns:
            - include: "#expression"
    expression-operators:
        patterns:
            - name: keyword.operator.assignment.compound.wave
              match: '\*=|/=|%=|\+=|-='
            - name: keyword.operator.assignment.compound.bitwise.wave
              match: '\&=|\^=|<<=|>>=|\|='
            - name: keyword.operator.bitwise.shift.wave
              match: "<<|>>"
            - name: keyword.operator.comparison.wave
              match: "==|!="
            - name: keyword.operator.relational.wave
              match: "<=|>=|<|>"
            - name: keyword.operator.logical.wave
              match: '\!|&&|\|\|'
            - name: keyword.operator.bitwise.wave
              match: '\&|~|\^|\|'
            - name: keyword.operator.assignment.wave
              match: \=
            - name: keyword.operator.decrement.wave
              match: "--"
            - name: keyword.operator.increment.wave
              match: \+\+
            - name: keyword.operator.arithmetic.wave
              match: '%|\*|/|-|\+'
            - name: keyword.operator.null-coalescing.wave
              match: '\?\?'
    conditional-operator:
        begin: '(?<!\?)\?(?!\?|\.|\[)'
        beginCaptures:
            "0":
                name: keyword.operator.conditional.question-mark.wave
        end: ":"
        endCaptures:
            "0":
                name: keyword.operator.conditional.colon.wave
        patterns:
            - include: "#expression"
    await-expression:
        name: keyword.other.await.wave
        match: '(?!\.)\b(await)\b'
    parenthesized-expression:
        begin: \(
        beginCaptures:
            "0":
                name: punctuation.parenthesis.open.wave
        end: \)
        endCaptures:
            "0":
                name: punctuation.parenthesis.close.wave
        patterns:
            - include: "#expression"
    initializer-expression:
        begin: '\{'
        beginCaptures:
            "0":
                name: punctuation.curlybrace.open.wave
        end: '\}'
        endCaptures:
            "0":
                name: punctuation.curlybrace.close.wave
        patterns:
            - include: "#expression"
            - include: "#punctuation-comma"
    identifier:
        name: variable.other.readwrite.wave
        match: "@?[_[:alpha:]][_[:alnum:]]*"
    cast-expression:
        match: "(?x)(\\()\\s*(?<type-name>  (?:    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))\\s*(\\))(?=\\s*@?[_[:alnum:]\\(])"
        captures:
            "1":
                name: punctuation.parenthesis.open.wave
            "2":
                patterns:
                    - { include: "#type" }
            "7":
                name: punctuation.parenthesis.close.wave
    as-expression:
        match: "(?x)(?<!\\.)\\b(as)\\b\\s*(?<type-name>  (?:    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))?"
        captures:
            "1":
                name: keyword.other.as.wave
            "2":
                patterns:
                    - { include: "#type" }
    is-expression:
        match: "(?x)(?<!\\.)\\b(is)\\b\\s*(?<type-name>  (?:    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))?"
        captures:
            "1":
                name: keyword.other.is.wave
            "2":
                patterns:
                    - { include: "#type" }
    this-or-base-expression:
        match: '\b(?:(base)|(this))\b'
        captures:
            "1":
                name: keyword.other.base.wave
            "2":
                name: keyword.other.this.wave
    invocation-expression:
        begin: "(?x)(?:(\\?)\\s*)?                                     # preceding null-conditional operator?(?:(\\.)\\s*)?                                     # preceding dot?(@?[_[:alpha:]][_[:alnum:]]*)\\s*                   # method name(?<type-args>\\s*<([^<>]|\\g<type-args>)+>\\s*)?\\s* # type arguments(?=\\()                                           # open paren of argument list"
        beginCaptures:
            "1":
                name: keyword.operator.null-conditional.wave
            "2":
                name: punctuation.accessor.wave
            "3":
                name: entity.name.function.wave
            "4":
                patterns:
                    - { include: "#type-arguments" }
        end: '(?<=\))'
        patterns:
            - include: "#argument-list"
    element-access-expression:
        begin: "(?x)(?:(\\?)\\s*)?                        # preceding null-conditional operator?(?:(\\.)\\s*)?                        # preceding dot?(?:(@?[_[:alpha:]][_[:alnum:]]*)\\s*)? # property name(?:(\\?)\\s*)?                        # null-conditional operator?(?=\\[)                              # open bracket of argument list"
        beginCaptures:
            "1":
                name: keyword.operator.null-conditional.wave
            "2":
                name: punctuation.accessor.wave
            "3":
                name: variable.other.object.property.wave
            "4":
                name: keyword.operator.null-conditional.wave
        end: '(?<=\])(?!\s*\[)'
        patterns:
            - include: "#bracketed-argument-list"
    member-access-expression:
        patterns:
            - match: "(?x)(?:(\\?)\\s*)?                   # preceding null-conditional operator?(\\.)\\s*                        # preceding dot(@?[_[:alpha:]][_[:alnum:]]*)\\s* # property name(?![_[:alnum:]]|\\(|(\\?)?\\[|<)  # next character is not alpha-numeric, nor a (, [, or <. Also, test for ?["
              captures:
                  "1": { name: keyword.operator.null-conditional.wave }
                  "2": { name: punctuation.accessor.wave }
                  "3": { name: variable.other.object.property.wave }
            - match: "(?x)(\\.)?\\s*(@?[_[:alpha:]][_[:alnum:]]*)(?<type-params>\\s*<([^<>]|\\g<type-params>)+>\\s*)(?=  (\\s*\\?)?  \\s*\\.\\s*@?[_[:alpha:]][_[:alnum:]]*)"
              captures:
                  "1": { name: punctuation.accessor.wave }
                  "2": { name: variable.other.object.wave }
                  "3": { patterns: [{ include: "#type-arguments" }] }
            - match: "(?x)(@?[_[:alpha:]][_[:alnum:]]*)(?=  (\\s*\\?)?  \\s*\\.\\s*@?[_[:alpha:]][_[:alnum:]]*)"
              captures:
                  "1": { name: variable.other.object.wave }
    object-creation-expression:
        patterns:
            - include: "#object-creation-expression-with-parameters"
            - include: "#object-creation-expression-with-no-parameters"
    object-creation-expression-with-parameters:
        begin: "(?x)(new)\\s+(?<type-name>  (?:    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))\\s*(?=\\()"
        beginCaptures:
            "1":
                name: keyword.other.new.wave
            "2":
                patterns:
                    - { include: "#type" }
        end: '(?<=\))'
        patterns:
            - include: "#argument-list"
    object-creation-expression-with-no-parameters:
        match: "(?x)(new)\\s+(?<type-name>  (?:    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))\\s*(?=\\{|$)"
        captures:
            "1":
                name: keyword.other.new.wave
            "2":
                patterns:
                    - { include: "#type" }
    array-creation-expression:
        begin: "(?x)\\b(new|stackalloc)\\b\\s*(?<type-name>  (?:    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))?\\s*(?=\\[)"
        beginCaptures:
            "1":
                name: keyword.other.new.wave
            "2":
                patterns:
                    - { include: "#type" }
        end: '(?<=\])'
        patterns:
            - include: "#bracketed-argument-list"
    anonymous-object-creation-expression:
        begin: '\b(new)\b\s*(?=\{|$)'
        beginCaptures:
            "1":
                name: keyword.other.new.wave
        end: '(?<=\})'
        patterns:
            - include: "#initializer-expression"
    bracketed-parameter-list:
        begin: '(?=(\[))'
        beginCaptures:
            "1":
                name: punctuation.squarebracket.open.wave
        end: '(?=(\]))'
        endCaptures:
            "1":
                name: punctuation.squarebracket.close.wave
        patterns:
            - begin: '(?<=\[)'
              end: '(?=\])'
              patterns:
                  - { include: "#comment" }
                  - { include: "#attribute-section" }
                  - { include: "#parameter" }
                  - { include: "#punctuation-comma" }
                  - { include: "#variable-initializer" }
    parenthesized-parameter-list:
        begin: (\()
        beginCaptures:
            "0":
                name: punctuation.parenthesis.open.wave
        end: (\))
        endCaptures:
            "0":
                name: punctuation.parenthesis.close.wave
        patterns:
            - include: "#comment"
            - include: "#attribute-section"
            - include: "#parameter"
            - include: "#punctuation-comma"
            - include: "#variable-initializer"
    parameter:
        match: "(?x)(?:(?:\\b(ref|params|out|in|this)\\b)\\s+)?(?<type-name>  (?:    (?:ref\\s+)?   # ref return    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))\\s+(\\g<identifier>)"
        captures:
            "1":
                name: storage.modifier.wave
            "2":
                patterns:
                    - { include: "#type" }
            "7":
                name: entity.name.variable.parameter.wave
    argument-list:
        begin: \(
        beginCaptures:
            "0":
                name: punctuation.parenthesis.open.wave
        end: \)
        endCaptures:
            "0":
                name: punctuation.parenthesis.close.wave
        patterns:
            - include: "#named-argument"
            - include: "#argument"
            - include: "#punctuation-comma"
    bracketed-argument-list:
        begin: '\['
        beginCaptures:
            "0":
                name: punctuation.squarebracket.open.wave
        end: '\]'
        endCaptures:
            "0":
                name: punctuation.squarebracket.close.wave
        patterns:
            - include: "#named-argument"
            - include: "#argument"
            - include: "#punctuation-comma"
    named-argument:
        begin: '(@?[_[:alpha:]][_[:alnum:]]*)\s*(:)'
        beginCaptures:
            "1":
                name: entity.name.variable.parameter.wave
            "2":
                name: punctuation.separator.colon.wave
        end: '(?=(,|\)|\]))'
        patterns:
            - include: "#argument"
    argument:
        patterns:
            - name: storage.modifier.wave
              match: \b(ref|out|in)\b
            - include: "#declaration-expression-local"
            - include: "#expression"
    query-expression:
        begin: "(?x)\\b(from)\\b\\s*(?<type-name>  (?:    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))?\\s+(\\g<identifier>)\\b\\s*\\b(in)\\b\\s*"
        beginCaptures:
            "1":
                name: keyword.query.from.wave
            "2":
                patterns:
                    - { include: "#type" }
            "7":
                name: entity.name.variable.range-variable.wave
            "8":
                name: keyword.query.in.wave
        end: '(?=;|\))'
        patterns:
            - include: "#query-body"
            - include: "#expression"
    query-body:
        patterns:
            - include: "#let-clause"
            - include: "#where-clause"
            - include: "#join-clause"
            - include: "#orderby-clause"
            - include: "#select-clause"
            - include: "#group-clause"
    let-clause:
        begin: "(?x)\\b(let)\\b\\s*(@?[_[:alpha:]][_[:alnum:]]*)\\b\\s*(=)\\s*"
        beginCaptures:
            "1":
                name: keyword.query.let.wave
            "2":
                name: entity.name.variable.range-variable.wave
            "3":
                name: keyword.operator.assignment.wave
        end: '(?=;|\))'
        patterns:
            - include: "#query-body"
            - include: "#expression"
    where-clause:
        begin: "(?x)\\b(where)\\b\\s*"
        beginCaptures:
            "1":
                name: keyword.query.where.wave
        end: '(?=;|\))'
        patterns:
            - include: "#query-body"
            - include: "#expression"
    join-clause:
        begin: "(?x)\\b(join)\\b\\s*(?<type-name>  (?:    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))?\\s+(\\g<identifier>)\\b\\s*\\b(in)\\b\\s*"
        beginCaptures:
            "1":
                name: keyword.query.join.wave
            "2":
                patterns:
                    - { include: "#type" }
            "7":
                name: entity.name.variable.range-variable.wave
            "8":
                name: keyword.query.in.wave
        end: '(?=;|\))'
        patterns:
            - include: "#join-on"
            - include: "#join-equals"
            - include: "#join-into"
            - include: "#query-body"
            - include: "#expression"
    join-on:
        match: '\b(on)\b\s*'
        captures:
            "1":
                name: keyword.query.on.wave
    join-equals:
        match: '\b(equals)\b\s*'
        captures:
            "1":
                name: keyword.query.equals.wave
    join-into:
        match: "(?x)\\b(into)\\b\\s*(@?[_[:alpha:]][_[:alnum:]]*)\\b\\s*"
        captures:
            "1":
                name: keyword.query.into.wave
            "2":
                name: entity.name.variable.range-variable.wave
    orderby-clause:
        begin: '\b(orderby)\b\s*'
        beginCaptures:
            "1":
                name: keyword.query.orderby.wave
        end: '(?=;|\))'
        patterns:
            - include: "#ordering-direction"
            - include: "#query-body"
            - include: "#expression"
            - include: "#punctuation-comma"
    ordering-direction:
        match: '\b(?:(ascending)|(descending))\b'
        captures:
            "1":
                name: keyword.query.ascending.wave
            "2":
                name: keyword.query.descending.wave
    select-clause:
        begin: '\b(select)\b\s*'
        beginCaptures:
            "1":
                name: keyword.query.select.wave
        end: '(?=;|\))'
        patterns:
            - include: "#query-body"
            - include: "#expression"
    group-clause:
        begin: '\b(group)\b\s*'
        beginCaptures:
            "1":
                name: keyword.query.group.wave
        end: '(?=;|\))'
        patterns:
            - include: "#group-by"
            - include: "#group-into"
            - include: "#query-body"
            - include: "#expression"
    group-by:
        match: '\b(by)\b\s*'
        captures:
            "1":
                name: keyword.query.by.wave
    group-into:
        match: "(?x)\\b(into)\\b\\s*(@?[_[:alpha:]][_[:alnum:]]*)\\b\\s*"
        captures:
            "1":
                name: keyword.query.into.wave
            "2":
                name: entity.name.variable.range-variable.wave
    anonymous-method-expression:
        patterns:
            - begin: "(?x)(?:\\b(async)\\b\\s*)?(@?[_[:alpha:]][_[:alnum:]]*)\\b\\s*(=>)"
              beginCaptures:
                  "1": { name: storage.modifier.wave }
                  "2": { name: entity.name.variable.parameter.wave }
                  "3": { name: keyword.operator.arrow.wave }
              end: '(?=\)|;|}|,)'
              patterns:
                  - { include: "#block" }
                  - { include: "#ref-modifier" }
                  - { include: "#expression" }
            - begin: "(?x)(?:\\b(async)\\b\\s*)?(\\(.*?\\))\\s*(=>)"
              beginCaptures:
                  "1": { name: storage.modifier.wave }
                  "2": { patterns: [{ include: "#lambda-parameter-list" }] }
                  "3": { name: keyword.operator.arrow.wave }
              end: '(?=\)|;|}|,)'
              patterns:
                  - { include: "#block" }
                  - { include: "#ref-modifier" }
                  - { include: "#expression" }
            - begin: "(?x)(?:\\b(async)\\b\\s*)?(?:\\b(delegate)\\b\\s*)"
              beginCaptures:
                  "1": { name: storage.modifier.wave }
                  "2": { name: keyword.other.delegate.wave }
              end: '(?=\)|;|}|,)'
              patterns:
                  - { include: "#parenthesized-parameter-list" }
                  - { include: "#block" }
                  - { include: "#expression" }
    lambda-parameter-list:
        begin: \(
        beginCaptures:
            "0":
                name: punctuation.parenthesis.open.wave
        end: \)
        endCaptures:
            "0":
                name: punctuation.parenthesis.close.wave
        patterns:
            - include: "#comment"
            - include: "#attribute-section"
            - include: "#lambda-parameter"
            - include: "#punctuation-comma"
    lambda-parameter:
        match: "(?x)(?:\\b(ref|out|in)\\b)?\\s*(?:(?<type-name>  (?:    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))\\s+)?(\\g<identifier>)\\b\\s*(?=[,)])"
        captures:
            "1":
                name: storage.modifier.wave
            "2":
                patterns:
                    - { include: "#type" }
            "7":
                name: entity.name.variable.parameter.wave
    type:
        name: meta.type.wave
        patterns:
            - include: "#comment"
            - include: "#ref-modifier"
            - include: "#readonly-modifier"
            - include: "#tuple-type"
            - include: "#type-builtin"
            - include: "#type-name"
            - include: "#type-arguments"
            - include: "#type-array-suffix"
            - include: "#type-nullable-suffix"
    ref-modifier:
        name: storage.modifier.wave
        match: \b(ref)\b
    readonly-modifier:
        name: storage.modifier.wave
        match: \b(readonly)\b
    tuple-type:
        begin: \(
        beginCaptures:
            "0":
                name: punctuation.parenthesis.open.wave
        end: \)
        endCaptures:
            "0":
                name: punctuation.parenthesis.close.wave
        patterns:
            - include: "#tuple-element"
            - include: "#punctuation-comma"
    tuple-element:
        match: "(?x)(?<type-name>  (?:    (?:      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification      (?<name-and-type-args> # identifier + type arguments (if any)        \\g<identifier>\\s*        (?<type-args>\\s*<(?:[^<>]|\\g<type-args>)+>\\s*)?      )      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))    )    (?:\\s*\\?\\s*)? # nullable suffix?    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?  ))(?:(?<tuple-name>\\g<identifier>)\\b)?"
        captures:
            "1":
                patterns:
                    - { include: "#type" }
            "6":
                name: entity.name.variable.tuple-element.wave
    type-builtin:
        match: \b(bool|byte|char|decimal|double|float|int|long|object|sbyte|short|string|uint|ulong|ushort|void|dynamic)\b
        captures:
            "1":
                name: keyword.type.wave
    type-name:
        patterns:
            - match: '(@?[_[:alpha:]][_[:alnum:]]*)\s*(\:\:)'
              captures:
                  "1": { name: entity.name.type.alias.wave }
                  "2": { name: punctuation.separator.coloncolon.wave }
            - match: '(@?[_[:alpha:]][_[:alnum:]]*)\s*(\.)'
              captures:
                  "1": { name: storage.type.wave }
                  "2": { name: punctuation.accessor.wave }
            - match: '(\.)\s*(@?[_[:alpha:]][_[:alnum:]]*)'
              captures:
                  "1": { name: punctuation.accessor.wave }
                  "2": { name: storage.type.wave }
            - name: storage.type.wave
              match: "@?[_[:alpha:]][_[:alnum:]]*"
    type-arguments:
        begin: "<"
        beginCaptures:
            "0":
                name: punctuation.definition.typeparameters.begin.wave
        end: ">"
        endCaptures:
            "0":
                name: punctuation.definition.typeparameters.end.wave
        patterns:
            - include: "#comment"
            - include: "#type"
            - include: "#punctuation-comma"
    type-array-suffix:
        begin: '\['
        beginCaptures:
            "0":
                name: punctuation.squarebracket.open.wave
        end: '\]'
        endCaptures:
            "0":
                name: punctuation.squarebracket.close.wave
        patterns:
            - include: "#punctuation-comma"
    type-nullable-suffix:
        match: '\?'
        captures:
            "0":
                name: punctuation.separator.question-mark.wave
    operator-assignment:
        name: keyword.operator.assignment.wave
        match: "(?<!=|!)(=)(?!=)"
    punctuation-comma:
        name: punctuation.separator.comma.wave
        match: ","
    punctuation-semicolon:
        name: punctuation.terminator.statement.wave
        match: ;
    punctuation-accessor:
        name: punctuation.accessor.wave
        match: \.
    preprocessor:
        name: meta.preprocessor.wave
        begin: '^\s*(\#)\s*'
        beginCaptures:
            "1":
                name: punctuation.separator.hash.wave
        end: "(?<=$)"
        patterns:
            - include: "#comment"
            - include: "#preprocessor-define-or-undef"
            - include: "#preprocessor-if-or-elif"
            - include: "#preprocessor-else-or-endif"
            - include: "#preprocessor-warning-or-error"
            - include: "#preprocessor-region"
            - include: "#preprocessor-endregion"
            - include: "#preprocessor-load"
            - include: "#preprocessor-r"
            - include: "#preprocessor-line"
            - include: "#preprocessor-pragma-warning"
            - include: "#preprocessor-pragma-checksum"
    preprocessor-define-or-undef:
        match: '\b(?:(define)|(undef))\b\s*\b([_[:alpha:]][_[:alnum:]]*)\b'
        captures:
            "1":
                name: keyword.preprocessor.define.wave
            "2":
                name: keyword.preprocessor.undef.wave
            "3":
                name: entity.name.variable.preprocessor.symbol.wave
    preprocessor-if-or-elif:
        begin: '\b(?:(if)|(elif))\b'
        beginCaptures:
            "1":
                name: keyword.preprocessor.if.wave
            "2":
                name: keyword.preprocessor.elif.wave
        end: "(?=$)"
        patterns:
            - include: "#comment"
            - include: "#preprocessor-expression"
    preprocessor-else-or-endif:
        match: '\b(?:(else)|(endif))\b'
        captures:
            "1":
                name: keyword.preprocessor.else.wave
            "2":
                name: keyword.preprocessor.endif.wave
    preprocessor-warning-or-error:
        match: '\b(?:(warning)|(error))\b\s*(.*)(?=$)'
        captures:
            "1":
                name: keyword.preprocessor.warning.wave
            "2":
                name: keyword.preprocessor.error.wave
            "3":
                name: string.unquoted.preprocessor.message.wave
    preprocessor-load:
        begin: \b(load)\b
        beginCaptures:
            "1":
                name: keyword.preprocessor.load.wave
        end: "(?=$)"
        patterns:
            - match: '\"[^"]*\"'
              captures:
                  "0": { name: string.quoted.double.wave }
    preprocessor-r:
        begin: \b(r)\b
        beginCaptures:
            "1":
                name: keyword.preprocessor.r.wave
        end: "(?=$)"
        patterns:
            - match: '\"[^"]*\"'
              captures:
                  "0": { name: string.quoted.double.wave }
    preprocessor-region:
        match: '\b(region)\b\s*(.*)(?=$)'
        captures:
            "1":
                name: keyword.preprocessor.region.wave
            "2":
                name: string.unquoted.preprocessor.message.wave
    preprocessor-endregion:
        match: \b(endregion)\b
        captures:
            "1":
                name: keyword.preprocessor.endregion.wave
    preprocessor-line:
        begin: \b(line)\b
        beginCaptures:
            "1":
                name: keyword.preprocessor.line.wave
        end: "(?=$)"
        patterns:
            - match: '\b(?:(default|hidden))'
              captures:
                  "1": { name: keyword.preprocessor.default.wave }
                  "2": { name: keyword.preprocessor.hidden.wave }
            - match: "[0-9]+"
              captures:
                  "0": { name: constant.numeric.decimal.wave }
            - match: '\"[^"]*\"'
              captures:
                  "0": { name: string.quoted.double.wave }
    preprocessor-pragma-warning:
        match: '\b(pragma)\b\s*\b(warning)\b\s*\b(?:(disable)|(restore))\b(\s*[0-9]+(?:\s*,\s*[0-9]+)?)?'
        captures:
            "1":
                name: keyword.preprocessor.pragma.wave
            "2":
                name: keyword.preprocessor.warning.wave
            "3":
                name: keyword.preprocessor.disable.wave
            "4":
                name: keyword.preprocessor.restore.wave
            "5":
                patterns:
                    - {
                          match: "[0-9]+",
                          captures:
                              { "0": { name: constant.numeric.decimal.wave } },
                      }
                    - { include: "#punctuation-comma" }
    preprocessor-pragma-checksum:
        match: '\b(pragma)\b\s*\b(checksum)\b\s*(\"[^"]*\")\s*(\"[^"]*\")\s*(\"[^"]*\")'
        captures:
            "1":
                name: keyword.preprocessor.pragma.wave
            "2":
                name: keyword.preprocessor.checksum.wave
            "3":
                name: string.quoted.double.wave
            "4":
                name: string.quoted.double.wave
            "5":
                name: string.quoted.double.wave
    preprocessor-expression:
        patterns:
            - begin: \(
              beginCaptures:
                  "0": { name: punctuation.parenthesis.open.wave }
              end: \)
              endCaptures:
                  "0": { name: punctuation.parenthesis.close.wave }
              patterns:
                  - { include: "#preprocessor-expression" }
            - match: '\b(?:(true)|(false)|([_[:alpha:]][_[:alnum:]]*))\b'
              captures:
                  "1": { name: constant.language.boolean.true.wave }
                  "2": { name: constant.language.boolean.false.wave }
                  "3": { name: entity.name.variable.preprocessor.symbol.wave }
            - match: '(==|!=)|(\!|&&|\|\|)'
              captures:
                  "1": { name: keyword.operator.comparison.wave }
                  "2": { name: keyword.operator.logical.wave }
    comment:
        patterns:
            - name: comment.block.wave
              begin: '/\*'
              beginCaptures:
                  "0": { name: punctuation.definition.comment.wave }
              end: '\*/'
              endCaptures:
                  "0": { name: punctuation.definition.comment.wave }
            - begin: '(^\s+)?(?=//)'
              beginCaptures:
                  "1": { name: punctuation.whitespace.comment.leading.wave }
              end: "(?=$)"
              patterns:
                  - {
                        name: comment.block.documentation.wave,
                        begin: "(?<!/)///(?!/)",
                        beginCaptures:
                            {
                                "0":
                                    { name: punctuation.definition.comment.wave },
                            },
                        end: "(?=$)",
                        patterns: [{ include: "#xml-doc-comment" }],
                    }
                  - {
                        name: comment.line.double-slash.wave,
                        begin: "(?<!/)//(?:(?!/)|(?=//))",
                        beginCaptures:
                            {
                                "0":
                                    { name: punctuation.definition.comment.wave },
                            },
                        end: "(?=$)",
                    }
    xml-doc-comment:
        patterns:
            - include: "#xml-comment"
            - include: "#xml-character-entity"
            - include: "#xml-cdata"
            - include: "#xml-tag"
    xml-tag:
        name: meta.tag.wave
        begin: "(?x)(</?)(  (?:    ([-_[:alnum:]]+)    (:)  )?  ([-_[:alnum:]]+))"
        beginCaptures:
            "1":
                name: punctuation.definition.tag.wave
            "2":
                name: entity.name.tag.wave
            "3":
                name: entity.name.tag.namespace.wave
            "4":
                name: punctuation.separator.colon.wave
            "5":
                name: entity.name.tag.localname.wave
        end: "(/?>)"
        endCaptures:
            "1":
                name: punctuation.definition.tag.wave
        patterns:
            - include: "#xml-attribute"
    xml-attribute:
        patterns:
            - match: "(?x)(?:^|\\s+)(  (?:    ([-_[:alnum:]]+)    (:)  )?  ([-_[:alnum:]]+))(=)"
              captures:
                  "1": { name: entity.other.attribute-name.wave }
                  "2": { name: entity.other.attribute-name.namespace.wave }
                  "3": { name: punctuation.separator.colon.wave }
                  "4": { name: entity.other.attribute-name.localname.wave }
                  "5": { name: punctuation.separator.equals.wave }
            - include: "#xml-string"
    xml-cdata:
        name: string.unquoted.cdata.wave
        begin: '<!\[CDATA\['
        beginCaptures:
            "0":
                name: punctuation.definition.string.begin.wave
        end: '\]\]>'
        endCaptures:
            "0":
                name: punctuation.definition.string.end.wave
    xml-string:
        patterns:
            - name: string.quoted.single.wave
              begin: '\'''
              beginCaptures:
                  "0": { name: punctuation.definition.string.begin.wave }
              end: '\'''
              endCaptures:
                  "0": { name: punctuation.definition.string.end.wave }
              patterns:
                  - { include: "#xml-character-entity" }
            - name: string.quoted.double.wave
              begin: '\"'
              beginCaptures:
                  "0": { name: punctuation.definition.string.begin.wave }
              end: '\"'
              endCaptures:
                  "0": { name: punctuation.definition.string.end.wave }
              patterns:
                  - { include: "#xml-character-entity" }
    xml-character-entity:
        patterns:
            - name: constant.character.entity.wave
              match: "(?x)(&)(  (?:[[:alpha:]:_][[:alnum:]:_.-]*)|  (?:\\#[[:digit:]]+)|  (?:\\#x[[:xdigit:]]+))(;)"
              captures:
                  "1": { name: punctuation.definition.constant.wave }
                  "3": { name: punctuation.definition.constant.wave }
            - name: invalid.illegal.bad-ampersand.wave
              match: "&"
    xml-comment:
        name: comment.block.wave
        begin: "<!--"
        beginCaptures:
            "0":
                name: punctuation.definition.comment.wave
        end: "-->"
        endCaptures:
            "0":
                name: punctuation.definition.comment.wave
